<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Terminal</title>
    <link rel="stylesheet" href="node_modules/@xterm/xterm/css/xterm.css" />
    <script src="node_modules/@xterm/xterm/lib/xterm.js"></script>
    <script src="node_modules/socket.io-client/dist/socket.io.min.js"></script>
    <script src="./terminal-env.js"></script>
</head>

<body style="margin: 0px;padding: 0px;">
    <div style="background-color: black;margin: 15px;padding: 15px;">
        <div id="terminal" style="overflow: auto;">
        </div>
    </div>
    <div style="position: fixed;width: 100vw;height: 100vh;top: 0;left: 0;display: flex;align-items: center;justify-content: center;font-weight: bold;font-size: 19px;background-color: rgba(0, 0, 0, 0.4);color: white;"
        id="connecting-indicator">
        Connecting to server...
    </div>

    <script type="module">
        const getConnectingIndicator = () => document.getElementById('connecting-indicator');

        getConnectingIndicator().onclick = e => {
            e.stopPropagation();
        };
        const isSecure = location.protocol === "https:" && window.isSecureContext;
        if (!isSecure) {
            console.warn('insecure protocol, enabling end to end encryption');
            await Promise.all([
                import('/node_modules/tweetnacl-functional/nacl-fast.js'),
                import('/e2e.js'),
                import('/node_modules/base64-js/base64js.min.js')
            ]);
        }

        const { pair, encrypt, decrypt } = isSecure ? {} : initE2E(nacl);

        const terminalRef = new Terminal({
            cols: globalThis.TERMINAL_COL,
            rows: globalThis.TERMINAL_ROW,
            cursorBlink: true
        });
        terminalRef.open(document.getElementById('terminal'));

        globalThis.terminalRef = terminalRef;

        terminalRef.onData(async (arg1, arg2) => {
            const data = isSecure ? arg1 : encrypt(arg1, await serverPubKey);
            terminalSocket.emit('write_server_terminal', data);
        });

        const wsPrefix = location.protocol === 'https:' ? 'wss' : 'ws';

        let serverPubKeyCallback;
        let serverPubKey = !isSecure && new Promise(resolve => {
            serverPubKeyCallback = resolve;
        });

        const terminalSocket = io(`${wsPrefix}://${origin.split('://')[1]}`, {
            transports: ['websocket', 'polling', 'flashsocket'],
            withCredentials: true,
            ...isSecure ? undefined : { auth: { pubKey: uint8ToBase64(pair.publicKey) } }
        });

        terminalSocket.on('e2e_exchange', function (pubKey) {
            pubKey = base64ToUint8(pubKey);
            serverPubKeyCallback(pubKey);
            serverPubKey = Promise.resolve(pubKey);
        });

        terminalSocket.on('mount_terminal', async function (data, acknowledge) {
            acknowledge?.();
            terminalRef.reset();
            const lines = isSecure ? data : decrypt(data, await serverPubKey);
            terminalRef.write(lines);
            getConnectingIndicator().style.display = 'none';
        });

        terminalSocket.on('write_client_terminal', async function (data, acknowledge) {
            acknowledge?.();
            const lines = isSecure ? data : decrypt(data, await serverPubKey);
            // console.log('write_client_terminal: ', data, ' line:', lines);
            terminalRef.write(lines);
            getConnectingIndicator().style.display = 'none';
        });

        terminalSocket.on('disconnect', () => {
            getConnectingIndicator().style.display = 'flex';
            terminalRef.blur();
        });

        terminalSocket.on('connect', () => {
            console.warn('reconnected');
        });
    </script>
</body>

</html>